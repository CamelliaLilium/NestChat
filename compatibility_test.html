<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NestChat å…¼å®¹æ€§è¯Šæ–­å·¥å…·</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .test-section h3 {
            margin-top: 0;
            color: #333;
        }
        .result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        button {
            background: #e91e63;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #c2185b;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .code-block {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”§ NestChat å…¼å®¹æ€§è¯Šæ–­å·¥å…·</h1>
        <p>Chrome 138.0.7204.97 å…¼å®¹æ€§æ·±åº¦æ£€æµ‹</p>
        
        <div class="test-section">
            <h3>ğŸŒ æµè§ˆå™¨åŸºæœ¬ä¿¡æ¯</h3>
            <button onclick="testBrowserInfo()">æ£€æµ‹æµè§ˆå™¨ä¿¡æ¯</button>
            <div id="browser-info"></div>
        </div>

        <div class="test-section">
            <h3>ğŸ¤ éŸ³é¢‘å½•åˆ¶æ·±åº¦æµ‹è¯•</h3>
            <button onclick="testAudioSupport()">æ£€æµ‹éŸ³é¢‘æ”¯æŒ</button>
            <button onclick="testMicrophoneAccess()">æµ‹è¯•éº¦å…‹é£æƒé™</button>
            <button onclick="testMediaRecorder()">æµ‹è¯•MediaRecorder</button>
            <button onclick="startTestRecording()" id="record-btn">å¼€å§‹æµ‹è¯•å½•éŸ³</button>
            <button onclick="stopTestRecording()" id="stop-btn" disabled>åœæ­¢å½•éŸ³</button>
            <div id="audio-results"></div>
        </div>

        <div class="test-section">
            <h3>ğŸ”Œ ç½‘ç»œè¿æ¥æµ‹è¯•</h3>
            <button onclick="testAPIConnection()">æµ‹è¯•APIè¿æ¥</button>
            <button onclick="testWebSocketConnection()">æµ‹è¯•WebSocket</button>
            <button onclick="testSocketIO()">æµ‹è¯•Socket.IO</button>
            <div id="network-results"></div>
        </div>

        <div class="test-section">
            <h3>ğŸ”’ å®‰å…¨ç­–ç•¥æ£€æµ‹</h3>
            <button onclick="testSecurityPolicies()">æ£€æµ‹å®‰å…¨ç­–ç•¥</button>
            <div id="security-results"></div>
        </div>

        <div class="test-section">
            <h3>ğŸ“‹ æƒé™çŠ¶æ€</h3>
            <button onclick="checkPermissions()">æ£€æŸ¥æƒé™çŠ¶æ€</button>
            <button onclick="requestAllPermissions()">è¯·æ±‚æ‰€æœ‰æƒé™</button>
            <div id="permissions-results"></div>
        </div>

        <div class="test-section">
            <h3>ğŸš€ ä¸€é”®ä¿®å¤</h3>
            <button onclick="runAutoFix()">è‡ªåŠ¨ä¿®å¤å¸¸è§é—®é¢˜</button>
            <div id="fix-results"></div>
        </div>
    </div>

    <script>
        let mediaRecorder = null;
        let audioChunks = [];
        let testStream = null;

        function addResult(containerId, message, type = 'info') {
            const container = document.getElementById(containerId);
            const div = document.createElement('div');
            div.className = `result ${type}`;
            div.innerHTML = `${new Date().toLocaleTimeString()} - ${message}`;
            container.appendChild(div);
        }

        function testBrowserInfo() {
            const container = document.getElementById('browser-info');
            container.innerHTML = '';
            
            const ua = navigator.userAgent;
            const info = {
                æµè§ˆå™¨: navigator.appName,
                ç‰ˆæœ¬: navigator.appVersion,
                ç”¨æˆ·ä»£ç†: ua,
                å¹³å°: navigator.platform,
                è¯­è¨€: navigator.language,
                Cookieå¯ç”¨: navigator.cookieEnabled,
                åœ¨çº¿çŠ¶æ€: navigator.onLine,
                ç¡¬ä»¶å¹¶å‘: navigator.hardwareConcurrency,
                å†…å­˜: navigator.deviceMemory ? navigator.deviceMemory + 'GB' : 'æœªçŸ¥'
            };

            // Chromeç‰ˆæœ¬æ£€æµ‹
            const chromeMatch = ua.match(/Chrome\/([0-9.]+)/);
            if (chromeMatch) {
                info['Chromeç‰ˆæœ¬'] = chromeMatch[1];
                const version = parseInt(chromeMatch[1]);
                if (version >= 88) {
                    addResult('browser-info', `âœ… Chromeç‰ˆæœ¬ ${chromeMatch[1]} æ”¯æŒæ‰€æœ‰åŠŸèƒ½`, 'success');
                } else {
                    addResult('browser-info', `âš ï¸ Chromeç‰ˆæœ¬ ${chromeMatch[1]} å¯èƒ½ä¸æ”¯æŒæŸäº›åŠŸèƒ½`, 'warning');
                }
            }

            Object.entries(info).forEach(([key, value]) => {
                addResult('browser-info', `${key}: ${value}`, 'info');
            });
        }

        async function testAudioSupport() {
            const container = document.getElementById('audio-results');
            container.innerHTML = '';

            // åŸºç¡€APIæ£€æµ‹
            const tests = [
                { name: 'navigator.mediaDevices', check: () => !!navigator.mediaDevices },
                { name: 'getUserMedia', check: () => !!navigator.mediaDevices?.getUserMedia },
                { name: 'MediaRecorder', check: () => !!window.MediaRecorder },
                { name: 'AudioContext', check: () => !!(window.AudioContext || window.webkitAudioContext) },
                { name: 'MediaStream', check: () => !!window.MediaStream }
            ];

            tests.forEach(test => {
                const supported = test.check();
                addResult('audio-results', 
                    `${test.name}: ${supported ? 'âœ… æ”¯æŒ' : 'âŒ ä¸æ”¯æŒ'}`, 
                    supported ? 'success' : 'error'
                );
            });

            // HTTPSæ£€æµ‹
            const isSecure = location.protocol === 'https:' || 
                           location.hostname === 'localhost' || 
                           location.hostname === '127.0.0.1';
            addResult('audio-results', 
                `å®‰å…¨ç¯å¢ƒ: ${isSecure ? 'âœ… å®‰å…¨' : 'âš ï¸ ä¸å®‰å…¨'}`, 
                isSecure ? 'success' : 'warning'
            );

            // MediaRecorderæ”¯æŒçš„æ ¼å¼
            if (window.MediaRecorder) {
                const formats = ['audio/webm', 'audio/mp4', 'audio/ogg'];
                formats.forEach(format => {
                    const supported = MediaRecorder.isTypeSupported(format);
                    addResult('audio-results', 
                        `${format}: ${supported ? 'âœ… æ”¯æŒ' : 'âŒ ä¸æ”¯æŒ'}`, 
                        supported ? 'success' : 'error'
                    );
                });
            }
        }

        async function testMicrophoneAccess() {
            try {
                addResult('audio-results', 'æ­£åœ¨è¯·æ±‚éº¦å…‹é£æƒé™...', 'info');
                
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                addResult('audio-results', 'âœ… éº¦å…‹é£æƒé™è·å–æˆåŠŸ', 'success');
                
                // æ£€æµ‹éŸ³é¢‘è½¨é“
                const audioTracks = stream.getAudioTracks();
                addResult('audio-results', `éŸ³é¢‘è½¨é“æ•°: ${audioTracks.length}`, 'info');
                
                if (audioTracks.length > 0) {
                    const track = audioTracks[0];
                    addResult('audio-results', `è®¾å¤‡æ ‡ç­¾: ${track.label}`, 'info');
                    addResult('audio-results', `è®¾å¤‡ID: ${track.id}`, 'info');
                    addResult('audio-results', `è½¨é“çŠ¶æ€: ${track.readyState}`, 'info');
                }
                
                // ç«‹å³åœæ­¢æµ
                stream.getTracks().forEach(track => track.stop());
                
            } catch (error) {
                addResult('audio-results', `âŒ éº¦å…‹é£è®¿é—®å¤±è´¥: ${error.name} - ${error.message}`, 'error');
                
                // è¯¦ç»†é”™è¯¯åˆ†æ
                switch (error.name) {
                    case 'NotAllowedError':
                        addResult('audio-results', 'ğŸ’¡ è§£å†³æ–¹æ¡ˆ: ç‚¹å‡»åœ°å€æ çš„ğŸ”’å›¾æ ‡ï¼Œå…è®¸éº¦å…‹é£æƒé™', 'warning');
                        break;
                    case 'NotFoundError':
                        addResult('audio-results', 'ğŸ’¡ è§£å†³æ–¹æ¡ˆ: æ£€æŸ¥éº¦å…‹é£ç¡¬ä»¶è¿æ¥', 'warning');
                        break;
                    case 'NotReadableError':
                        addResult('audio-results', 'ğŸ’¡ è§£å†³æ–¹æ¡ˆ: éº¦å…‹é£è¢«å…¶ä»–åº”ç”¨å ç”¨ï¼Œè¯·å…³é—­å…¶ä»–éŸ³é¢‘åº”ç”¨', 'warning');
                        break;
                    case 'OverconstrainedError':
                        addResult('audio-results', 'ğŸ’¡ è§£å†³æ–¹æ¡ˆ: éº¦å…‹é£ä¸æ”¯æŒè¯·æ±‚çš„å‚æ•°', 'warning');
                        break;
                    case 'SecurityError':
                        addResult('audio-results', 'ğŸ’¡ è§£å†³æ–¹æ¡ˆ: éœ€è¦HTTPSç¯å¢ƒæˆ–localhost', 'warning');
                        break;
                }
            }
        }

        async function testMediaRecorder() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // æµ‹è¯•ä¸åŒçš„MIMEç±»å‹
                const mimeTypes = [
                    'audio/webm',
                    'audio/webm;codecs=opus',
                    'audio/mp4',
                    'audio/ogg;codecs=opus'
                ];
                
                for (const mimeType of mimeTypes) {
                    try {
                        const recorder = new MediaRecorder(stream, { mimeType });
                        addResult('audio-results', `âœ… MediaRecorderæ”¯æŒ: ${mimeType}`, 'success');
                    } catch (e) {
                        addResult('audio-results', `âŒ MediaRecorderä¸æ”¯æŒ: ${mimeType}`, 'error');
                    }
                }
                
                stream.getTracks().forEach(track => track.stop());
                
            } catch (error) {
                addResult('audio-results', `âŒ MediaRecorderæµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function startTestRecording() {
            try {
                addResult('audio-results', 'å¼€å§‹æµ‹è¯•å½•éŸ³...', 'info');
                
                testStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(testStream);
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                    addResult('audio-results', `ğŸ“ å½•éŸ³æ•°æ®å—: ${event.data.size} bytes`, 'info');
                };
                
                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    addResult('audio-results', `âœ… å½•éŸ³å®Œæˆï¼Œå¤§å°: ${audioBlob.size} bytes`, 'success');
                    
                    // åˆ›å»ºæ’­æ”¾é“¾æ¥
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = document.createElement('audio');
                    audio.controls = true;
                    audio.src = audioUrl;
                    document.getElementById('audio-results').appendChild(audio);
                };
                
                mediaRecorder.start();
                document.getElementById('record-btn').disabled = true;
                document.getElementById('stop-btn').disabled = false;
                
                addResult('audio-results', 'ğŸ¤ å½•éŸ³å·²å¼€å§‹ï¼Œè¯·è¯´è¯...', 'success');
                
            } catch (error) {
                addResult('audio-results', `âŒ å½•éŸ³å¯åŠ¨å¤±è´¥: ${error.message}`, 'error');
            }
        }

        function stopTestRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                testStream.getTracks().forEach(track => track.stop());
                
                document.getElementById('record-btn').disabled = false;
                document.getElementById('stop-btn').disabled = true;
                
                addResult('audio-results', 'â¹ï¸ å½•éŸ³å·²åœæ­¢', 'info');
            }
        }

        async function testAPIConnection() {
            const serverIP = '10.122.239.128';
            const apiUrl = `http://${serverIP}:3001/api/v1/health`;
            
            try {
                addResult('network-results', `æµ‹è¯•APIè¿æ¥: ${apiUrl}`, 'info');
                
                const response = await fetch(apiUrl);
                if (response.ok) {
                    const data = await response.json();
                    addResult('network-results', `âœ… APIè¿æ¥æˆåŠŸ: ${JSON.stringify(data)}`, 'success');
                } else {
                    addResult('network-results', `âš ï¸ APIå“åº”å¼‚å¸¸: HTTP ${response.status}`, 'warning');
                }
            } catch (error) {
                addResult('network-results', `âŒ APIè¿æ¥å¤±è´¥: ${error.message}`, 'error');
                addResult('network-results', `ğŸ’¡ è¯·æ£€æŸ¥åç«¯æœåŠ¡æ˜¯å¦å¯åŠ¨: node server.js`, 'warning');
            }
        }

        function testWebSocketConnection() {
            const serverIP = '10.122.239.128';
            const wsUrl = `ws://${serverIP}:3001`;
            
            addResult('network-results', `æµ‹è¯•WebSocketè¿æ¥: ${wsUrl}`, 'info');
            
            const ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                addResult('network-results', 'âœ… WebSocketè¿æ¥æˆåŠŸ', 'success');
                ws.close();
            };
            
            ws.onerror = (error) => {
                addResult('network-results', `âŒ WebSocketè¿æ¥å¤±è´¥: ${error}`, 'error');
            };
            
            ws.onclose = () => {
                addResult('network-results', 'WebSocketè¿æ¥å·²å…³é—­', 'info');
            };
            
            // 10ç§’è¶…æ—¶
            setTimeout(() => {
                if (ws.readyState !== WebSocket.OPEN) {
                    addResult('network-results', 'âŒ WebSocketè¿æ¥è¶…æ—¶', 'error');
                    ws.close();
                }
            }, 10000);
        }

        function testSocketIO() {
            // è¿™é‡Œéœ€è¦åŠ è½½Socket.IOåº“æ‰èƒ½æµ‹è¯•
            addResult('network-results', 'âš ï¸ Socket.IOæµ‹è¯•éœ€è¦åœ¨å®é™…åº”ç”¨ä¸­è¿›è¡Œ', 'warning');
        }

        function testSecurityPolicies() {
            const container = document.getElementById('security-results');
            container.innerHTML = '';
            
            // å®‰å…¨ç­–ç•¥æ£€æµ‹
            const policies = [
                { name: 'HTTPS', check: () => location.protocol === 'https:' },
                { name: 'Same-Origin', check: () => window.origin === location.origin },
                { name: 'Secure Context', check: () => window.isSecureContext },
                { name: 'Cross-Origin-Isolation', check: () => window.crossOriginIsolated }
            ];
            
            policies.forEach(policy => {
                const result = policy.check();
                addResult('security-results', 
                    `${policy.name}: ${result ? 'âœ… æ­£å¸¸' : 'âš ï¸ å—é™'}`, 
                    result ? 'success' : 'warning'
                );
            });
            
            // CSPæ£€æµ‹
            const meta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
            if (meta) {
                addResult('security-results', `CSPç­–ç•¥: ${meta.content}`, 'info');
            } else {
                addResult('security-results', 'CSPç­–ç•¥: æœªè®¾ç½®', 'info');
            }
        }

        async function checkPermissions() {
            const container = document.getElementById('permissions-results');
            container.innerHTML = '';
            
            if (!navigator.permissions) {
                addResult('permissions-results', 'âŒ Permissions APIä¸æ”¯æŒ', 'error');
                return;
            }
            
            const permissions = ['microphone', 'camera', 'notifications'];
            
            for (const permission of permissions) {
                try {
                    const result = await navigator.permissions.query({ name: permission });
                    addResult('permissions-results', 
                        `${permission}: ${result.state}`, 
                        result.state === 'granted' ? 'success' : 
                        result.state === 'prompt' ? 'warning' : 'error'
                    );
                } catch (error) {
                    addResult('permissions-results', `${permission}: æ£€æµ‹å¤±è´¥`, 'error');
                }
            }
        }

        async function requestAllPermissions() {
            try {
                // è¯·æ±‚éº¦å…‹é£æƒé™
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                addResult('permissions-results', 'âœ… éº¦å…‹é£æƒé™å·²è·å–', 'success');
                stream.getTracks().forEach(track => track.stop());
                
                // åˆ·æ–°æƒé™æ£€æŸ¥
                setTimeout(checkPermissions, 1000);
                
            } catch (error) {
                addResult('permissions-results', `âŒ æƒé™è¯·æ±‚å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function runAutoFix() {
            const container = document.getElementById('fix-results');
            container.innerHTML = '';
            
            addResult('fix-results', 'ğŸ”§ å¼€å§‹è‡ªåŠ¨ä¿®å¤...', 'info');
            
            // 1. æ£€æŸ¥å¹¶è¯·æ±‚æƒé™
            try {
                await requestAllPermissions();
                addResult('fix-results', 'âœ… æƒé™ä¿®å¤å®Œæˆ', 'success');
            } catch (error) {
                addResult('fix-results', 'âŒ æƒé™ä¿®å¤å¤±è´¥', 'error');
            }
            
            // 2. æ¸…é™¤ç¼“å­˜æç¤º
            addResult('fix-results', 'ğŸ’¡ å»ºè®®æ¸…é™¤æµè§ˆå™¨ç¼“å­˜: Ctrl+Shift+Delete', 'warning');
            
            // 3. é‡æ–°åŠ è½½æç¤º
            addResult('fix-results', 'ğŸ’¡ å»ºè®®é‡æ–°åŠ è½½é¡µé¢ä»¥åº”ç”¨ä¿®å¤', 'warning');
            
            // 4. ç”Ÿæˆä¿®å¤æŠ¥å‘Š
            const report = `
=== Chrome 138 å…¼å®¹æ€§ä¿®å¤æŠ¥å‘Š ===
æ—¶é—´: ${new Date().toLocaleString()}
æµè§ˆå™¨: ${navigator.userAgent}
URL: ${location.href}

å»ºè®®æ“ä½œ:
1. ç¡®ä¿éº¦å…‹é£æƒé™å·²æˆäºˆ
2. æ¸…é™¤æµè§ˆå™¨ç¼“å­˜å’Œç«™ç‚¹æ•°æ®
3. é‡å¯æµè§ˆå™¨
4. æ£€æŸ¥é˜²ç«å¢™è®¾ç½®
5. ç¡®è®¤åç«¯æœåŠ¡è¿è¡Œæ­£å¸¸

å¦‚æœé—®é¢˜ä»ç„¶å­˜åœ¨ï¼Œè¯·æä¾›æ­¤æŠ¥å‘Šç»™æŠ€æœ¯æ”¯æŒã€‚
            `;
            
            const blob = new Blob([report], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'nestchat-compatibility-report.txt';
            a.textContent = 'ğŸ“„ ä¸‹è½½è¯¦ç»†æŠ¥å‘Š';
            container.appendChild(a);
        }

        // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨è¿è¡ŒåŸºç¡€æ£€æµ‹
        window.onload = function() {
            testBrowserInfo();
            testAudioSupport();
        };
    </script>
</body>
</html>
