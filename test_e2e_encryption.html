<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>端到端加密通信测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .test-section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        input, textarea {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .image-container {
            max-width: 300px;
            margin: 10px 0;
        }
        .image-container img {
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>🔐 端到端加密通信测试</h1>
    <p>测试RSA密钥协商、AES加密解密、LSB图片隐写术的完整流程</p>

    <!-- RSA密钥对生成测试 -->
    <div class="test-section">
        <h2>1. RSA密钥对生成测试</h2>
        <button onclick="testRSAKeyGeneration()">生成RSA密钥对</button>
        <div id="rsa-result"></div>
    </div>

    <!-- AES加密解密测试 -->
    <div class="test-section">
        <h2>2. AES加密解密测试</h2>
        <input type="text" id="text-to-encrypt" placeholder="输入要加密的文本" value="Hello, 这是一条测试消息! 🌟">
        <button onclick="testAESEncryption()">加密/解密测试</button>
        <div id="aes-result"></div>
    </div>

    <!-- 图片隐写术测试 -->
    <div class="test-section">
        <h2>3. 图片隐写术测试</h2>
        <input type="text" id="text-to-hide" placeholder="输入要隐藏的文本" value="这是一个秘密消息 🎭">
        <button onclick="testSteganography()">隐写/提取测试</button>
        <div id="stego-result"></div>
    </div>

    <!-- 端到端加密通信完整流程测试 -->
    <div class="test-section">
        <h2>4. 端到端加密通信完整流程测试</h2>
        <input type="email" id="peer-email" placeholder="对方邮箱" value="test@example.com">
        <textarea id="message-content" placeholder="输入消息内容" rows="3">这是一条端到端加密的测试消息，支持中文和Emoji 🔒🚀</textarea>
        <button onclick="testE2EEncryption()">完整流程测试</button>
        <div id="e2e-result"></div>
    </div>

    <!-- 性能测试 -->
    <div class="test-section">
        <h2>5. 性能测试</h2>
        <button onclick="testPerformance()">运行性能测试</button>
        <div id="performance-result"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsencrypt/3.3.2/jsencrypt.min.js"></script>
    <script>
        // 简化版加密管理器（用于测试）
        class TestEncryptionManager {
            constructor() {
                this.sessionKeys = new Map();
                this.initRSAKeys();
            }

            initRSAKeys() {
                try {
                    const encrypt = new JSEncrypt({ default_key_size: 1024 });
                    encrypt.getKey();
                    this.publicKey = encrypt.getPublicKey();
                    this.privateKey = encrypt.getPrivateKey();
                    this.keyPair = encrypt;
                    return true;
                } catch (error) {
                    console.error('RSA密钥生成失败:', error);
                    return false;
                }
            }

            generateSessionKey(peerEmail) {
                const aesKey = CryptoJS.lib.WordArray.random(256/8).toString();
                this.sessionKeys.set(peerEmail, aesKey);
                return aesKey;
            }

            encryptText(text, aesKey) {
                return CryptoJS.AES.encrypt(text, aesKey).toString();
            }

            decryptText(encryptedText, aesKey) {
                const bytes = CryptoJS.AES.decrypt(encryptedText, aesKey);
                return bytes.toString(CryptoJS.enc.Utf8);
            }

            // 简化的LSB隐写术（仅用于测试，真实项目中应使用更完善的实现）
            async encodeTextInImage(text) {
                // 创建一个简单的测试图片（canvas）
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');
                
                // 填充随机像素
                const imageData = ctx.createImageData(100, 100);
                for (let i = 0; i < imageData.data.length; i += 4) {
                    imageData.data[i] = Math.floor(Math.random() * 256);     // R
                    imageData.data[i + 1] = Math.floor(Math.random() * 256); // G
                    imageData.data[i + 2] = Math.floor(Math.random() * 256); // B
                    imageData.data[i + 3] = 255; // A
                }
                
                // 将文本编码到蓝色通道的LSB
                const textBytes = new TextEncoder().encode(text);
                const lenBytes = new Uint8Array(4);
                const len = textBytes.length;
                lenBytes[0] = (len >> 24) & 0xFF;
                lenBytes[1] = (len >> 16) & 0xFF;
                lenBytes[2] = (len >> 8) & 0xFF;
                lenBytes[3] = len & 0xFF;
                
                const allBytes = new Uint8Array(4 + textBytes.length);
                allBytes.set(lenBytes, 0);
                allBytes.set(textBytes, 4);
                
                // 转为比特数组
                const bits = [];
                for (let i = 0; i < allBytes.length; i++) {
                    for (let b = 7; b >= 0; b--) {
                        bits.push((allBytes[i] >> b) & 1);
                    }
                }
                
                // 将比特隐写到蓝色通道
                for (let i = 0; i < bits.length && i * 4 + 2 < imageData.data.length; i++) {
                    const pixelIndex = i * 4 + 2; // 蓝色通道
                    imageData.data[pixelIndex] = (imageData.data[pixelIndex] & 0xFE) | bits[i];
                }
                
                ctx.putImageData(imageData, 0, 0);
                return canvas.toDataURL('image/png');
            }

            async decodeTextFromImage(imageBase64) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        
                        const imageData = ctx.getImageData(0, 0, img.width, img.height);
                        
                        // 提取长度（前32位）
                        let len = 0;
                        for (let i = 0; i < 32; i++) {
                            const pixelIndex = i * 4 + 2; // 蓝色通道
                            const bit = imageData.data[pixelIndex] & 0x01;
                            len = (len << 1) | bit;
                        }
                        
                        // 提取文本数据
                        const textBytes = new Uint8Array(len);
                        for (let i = 0; i < len; i++) {
                            let byte = 0;
                            for (let b = 0; b < 8; b++) {
                                const pixelIndex = (32 + i * 8 + b) * 4 + 2;
                                if (pixelIndex < imageData.data.length) {
                                    const bit = imageData.data[pixelIndex] & 0x01;
                                    byte = (byte << 1) | bit;
                                }
                            }
                            textBytes[i] = byte;
                        }
                        
                        const text = new TextDecoder().decode(textBytes);
                        resolve(text);
                    };
                    img.onerror = reject;
                    img.src = imageBase64;
                });
            }
        }

        const testManager = new TestEncryptionManager();

        function displayResult(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            const div = document.createElement('div');
            div.className = `test-result ${type}`;
            div.innerHTML = message;
            element.appendChild(div);
        }

        function clearResults(elementId) {
            document.getElementById(elementId).innerHTML = '';
        }

        function testRSAKeyGeneration() {
            clearResults('rsa-result');
            try {
                const success = testManager.initRSAKeys();
                if (success) {
                    displayResult('rsa-result', '✅ RSA密钥对生成成功', 'success');
                    displayResult('rsa-result', `公钥长度: ${testManager.publicKey.length} 字符`, 'info');
                    displayResult('rsa-result', `公钥前100字符: ${testManager.publicKey.substring(0, 100)}...`, 'info');
                } else {
                    displayResult('rsa-result', '❌ RSA密钥对生成失败', 'error');
                }
            } catch (error) {
                displayResult('rsa-result', `❌ 错误: ${error.message}`, 'error');
            }
        }

        function testAESEncryption() {
            clearResults('aes-result');
            try {
                const text = document.getElementById('text-to-encrypt').value;
                const sessionKey = testManager.generateSessionKey('test@example.com');
                
                displayResult('aes-result', `🔑 生成会话密钥: ${sessionKey.substring(0, 16)}...`, 'info');
                
                const encrypted = testManager.encryptText(text, sessionKey);
                displayResult('aes-result', `🔒 加密结果: ${encrypted.substring(0, 50)}...`, 'info');
                
                const decrypted = testManager.decryptText(encrypted, sessionKey);
                displayResult('aes-result', `🔓 解密结果: ${decrypted}`, 'info');
                
                if (text === decrypted) {
                    displayResult('aes-result', '✅ AES加密解密测试成功', 'success');
                } else {
                    displayResult('aes-result', '❌ AES加密解密测试失败', 'error');
                }
            } catch (error) {
                displayResult('aes-result', `❌ 错误: ${error.message}`, 'error');
            }
        }

        async function testSteganography() {
            clearResults('stego-result');
            try {
                const text = document.getElementById('text-to-hide').value;
                
                displayResult('stego-result', `📝 原始文本: ${text}`, 'info');
                
                const encodedImage = await testManager.encodeTextInImage(text);
                displayResult('stego-result', '🎭 文本已隐写到图片中', 'info');
                
                // 显示隐写后的图片
                const imageContainer = document.createElement('div');
                imageContainer.className = 'image-container';
                imageContainer.innerHTML = `<img src="${encodedImage}" alt="隐写后的图片">`;
                document.getElementById('stego-result').appendChild(imageContainer);
                
                const decodedText = await testManager.decodeTextFromImage(encodedImage);
                displayResult('stego-result', `🔍 提取的文本: ${decodedText}`, 'info');
                
                if (text === decodedText) {
                    displayResult('stego-result', '✅ 图片隐写术测试成功', 'success');
                } else {
                    displayResult('stego-result', '❌ 图片隐写术测试失败', 'error');
                }
            } catch (error) {
                displayResult('stego-result', `❌ 错误: ${error.message}`, 'error');
            }
        }

        async function testE2EEncryption() {
            clearResults('e2e-result');
            try {
                const peerEmail = document.getElementById('peer-email').value;
                const messageContent = document.getElementById('message-content').value;
                
                displayResult('e2e-result', '🚀 开始端到端加密通信测试...', 'info');
                
                // 1. 生成会话密钥
                const sessionKey = testManager.generateSessionKey(peerEmail);
                displayResult('e2e-result', `🔑 步骤1: 生成会话密钥`, 'info');
                
                // 2. 构造消息包
                const messagePacket = {
                    type: 'text',
                    content: messageContent,
                    timestamp: Date.now(),
                    sessionKey: sessionKey
                };
                const messageJson = JSON.stringify(messagePacket);
                displayResult('e2e-result', `📦 步骤2: 构造消息包`, 'info');
                
                // 3. AES加密
                const encryptedMessage = testManager.encryptText(messageJson, sessionKey);
                displayResult('e2e-result', `🔒 步骤3: AES加密完成`, 'info');
                
                // 4. 图片隐写
                const steganographyImage = await testManager.encodeTextInImage(encryptedMessage);
                displayResult('e2e-result', `🎭 步骤4: 图片隐写完成`, 'info');
                
                // 显示隐写图片
                const imageContainer = document.createElement('div');
                imageContainer.className = 'image-container';
                imageContainer.innerHTML = `<img src="${steganographyImage}" alt="加密隐写后的图片">`;
                document.getElementById('e2e-result').appendChild(imageContainer);
                
                // 5. 解隐写
                const extractedEncryptedMessage = await testManager.decodeTextFromImage(steganographyImage);
                displayResult('e2e-result', `🔍 步骤5: 图片解隐写完成`, 'info');
                
                // 6. AES解密
                const decryptedMessageJson = testManager.decryptText(extractedEncryptedMessage, sessionKey);
                const decryptedMessagePacket = JSON.parse(decryptedMessageJson);
                displayResult('e2e-result', `🔓 步骤6: AES解密完成`, 'info');
                
                // 7. 验证结果
                displayResult('e2e-result', `📝 解密后的消息: ${decryptedMessagePacket.content}`, 'info');
                displayResult('e2e-result', `⏰ 消息时间戳: ${new Date(decryptedMessagePacket.timestamp).toLocaleString()}`, 'info');
                
                if (messageContent === decryptedMessagePacket.content) {
                    displayResult('e2e-result', '✅ 端到端加密通信完整流程测试成功！', 'success');
                } else {
                    displayResult('e2e-result', '❌ 端到端加密通信完整流程测试失败', 'error');
                }
                
            } catch (error) {
                displayResult('e2e-result', `❌ 错误: ${error.message}`, 'error');
            }
        }

        async function testPerformance() {
            clearResults('performance-result');
            try {
                displayResult('performance-result', '⚡ 开始性能测试...', 'info');
                
                const testData = [
                    { size: '短文本', content: 'Hello' },
                    { size: '中等文本', content: 'Hello World! 这是一条测试消息。'.repeat(10) },
                    { size: '长文本', content: 'Hello World! 这是一条测试消息。'.repeat(100) }
                ];
                
                for (const test of testData) {
                    const startTime = performance.now();
                    
                    // 完整的加密-隐写-解隐写-解密流程
                    const sessionKey = testManager.generateSessionKey('performance-test');
                    const encrypted = testManager.encryptText(test.content, sessionKey);
                    const stegoImage = await testManager.encodeTextInImage(encrypted);
                    const extracted = await testManager.decodeTextFromImage(stegoImage);
                    const decrypted = testManager.decryptText(extracted, sessionKey);
                    
                    const endTime = performance.now();
                    const duration = (endTime - startTime).toFixed(2);
                    
                    const success = test.content === decrypted;
                    const resultType = success ? 'success' : 'error';
                    const status = success ? '✅' : '❌';
                    
                    displayResult('performance-result', 
                        `${status} ${test.size} (${test.content.length}字符): ${duration}ms`, 
                        resultType
                    );
                }
                
                displayResult('performance-result', '⚡ 性能测试完成', 'info');
                
            } catch (error) {
                displayResult('performance-result', `❌ 性能测试错误: ${error.message}`, 'error');
            }
        }

        // 页面加载时自动运行一次基础测试
        window.onload = function() {
            setTimeout(() => {
                testRSAKeyGeneration();
            }, 500);
        };
    </script>
</body>
</html>
